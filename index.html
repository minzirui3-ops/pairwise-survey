<script>
(function () {
  // 固定端点 & manifest（避免被 URL 参数覆盖）
  const manifestURL = 'https://minzirui3-ops.github.io/pairwise-survey/manifest.json';
  const endpointURL = 'https://daili-jogcnerjku.cn-hangzhou.fcapp.run/submit';

  const $ = (s) => document.querySelector(s);
  const qs = new URLSearchParams(location.search);

  const allowTie = qs.get("allowTie") !== "0";
  const minK = parseInt(qs.get("k") || "5", 10);
  const respondent = (qs.get("rid") || localStorage.getItem('rid') || '').trim();
  const sessionId = "" + Date.now();

  const prog = $("#prog"), bar = $("#bar"), who = $("#who"), sess = $("#sess");
  const imgA = $("#imgA"), imgB = $("#imgB"), pairInfo = $("#pairInfo");

  if (!respondent) {
    const gen = 'guest-' + Math.floor(Math.random() * 1e6);
    localStorage.setItem('rid', gen);
    location.reload();
    return;
  }
  who.textContent = respondent;
  sess.textContent = sessionId;

  let images = [], names = [], counts = new Map(), pairSeen = new Set(), plan = [];
  let idx = 0, cur = null;

  const decodedCache = new Map();
  const toWebp = (u)=> u.replace(/\.png$/i, '.webp');

  // 直接 application/json
  function postResult(payload){
    fetch(endpointURL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      keepalive: true
    }).catch(()=>{});
  }

  ["voteA","voteB","voteTie","voteSkip"].forEach(id=>{
    const el = document.getElementById(id);
    el.addEventListener('pointerdown', e=>{
      e.preventDefault();
      if(id==="voteA") vote(1);
      else if(id==="voteB") vote(-1);
      else if(id==="voteTie" && allowTie) vote(0);
      else if(id==="voteSkip") vote('skip');
    }, {passive:false});
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "a" || e.key === "A") vote(1);
    if (e.key === "l" || e.key === "L") vote(-1);
    if (e.key === "e" || e.key === "E") if (allowTie) vote(0);
    if (e.key === "s" || e.key === "S") vote("skip");
  });

  fetch(manifestURL)
    .then((r) => r.json())
    .then((list) => {
      images = list.filter((u) => typeof u === "string");
      names  = images.map((u) => u.split("/").pop());
      names.forEach((n) => counts.set(n, 0));
      buildPlan();
      render();
    })
    .catch((err) => {
      console.error(err);
      alert("加载 manifest 失败");
    });

  function pairKey(a, b) { return [a, b].sort().join("__"); }
  function needPairsLeft() {
    const shortage = names.reduce((acc, n) => acc + Math.max(0, minK - (counts.get(n) || 0)), 0);
    return Math.ceil(shortage / 2);
  }

  function buildPlan() {
    plan = [];
    const cnt = new Map(counts);
    const need = new Set(names.filter((n) => (cnt.get(n) || 0) < minK));
    while (need.size) {
      const x = Array.from(need).sort((a, b) =>
        (cnt.get(a) || 0) - (cnt.get(b) || 0) || Math.random() - 0.5
      )[0];
      const candidates = names.slice().sort((a, b) =>
        (cnt.get(a) || 0) - (cnt.get(b) || 0) || Math.random() - 0.5
      );
      let paired = false;
      for (const y of candidates) {
        if (y === x) continue;
        const key = pairKey(x, y);
        if (pairSeen.has(key)) continue;
        plan.push({ a: x, b: y });
        pairSeen.add(key);
        cnt.set(x, (cnt.get(x) || 0) + 1);
        cnt.set(y, (cnt.get(y) || 0) + 1);
        if ((cnt.get(x) || 0) >= minK) need.delete(x);
        if (need.has(y) && (cnt.get(y) || 0) >= minK) need.delete(y);
        paired = true; break;
      }
      if (!paired) {
        for (const y of names) {
          if (y === x) continue;
          const key = pairKey(x, y);
          if (!pairSeen.has(key)) {
            plan.push({ a: x, b: y });
            pairSeen.add(key);
            cnt.set(x, (cnt.get(x) || 0) + 1);
            cnt.set(y, (cnt.get(y) || 0) + 1);
            if ((cnt.get(x) || 0) >= minK) need.delete(x);
            if (need.has(y) && (cnt.get(y) || 0) >= minK) need.delete(y);
            paired = true; break;
          }
        }
      }
      if (!paired) break;
    }
    shuffle(plan);
    idx = 0;
  }

  function setWithFallback(img, urlPng){
    const urlWebp = toWebp(urlPng);
    img.onerror = function(){ img.onerror = null; img.src = urlPng; };
    img.src = urlWebp;
  }

  async function preparePair(i){
    if (decodedCache.has(i) || i >= plan.length) return;
    const p = plan[i];
    const uA = images[names.indexOf(p.a)];
    const uB = images[names.indexOf(p.b)];
    const aOk = await preload(toWebp(uA)) || await preload(uA);
    const bOk = await preload(toWebp(uB)) || await preload(uB);
    if (aOk && bOk) decodedCache.set(i, { aUrl: aOk, bUrl: bOk });
  }

  function preload(url){
    return new Promise((resolve)=>{
      const im = new Image();
      im.decoding = 'async';
      im.loading  = 'eager';
      im.src = url;
      (im.decode?.() || Promise.resolve()).then(()=>resolve(url)).catch(()=>{});
      im.onload = ()=> resolve(url);
      im.onerror = ()=> resolve(null);
    });
  }

  function warmUpFrom(i){ for (let k=1;k<=4;k++) preparePair(i+k); }

  function render() {
    if (idx >= plan.length) {
      const left = needPairsLeft();
      prog.textContent = `${plan.length} / ${plan.length}`;
      bar.style.width = "100%";
      pairInfo.textContent = left > 0
        ? `本轮已完成。剩余理论最少配对约 ${left} 组（基于K=${minK}）`
        : "本轮已完成，感谢参与！";
      imgA.removeAttribute("src"); imgB.removeAttribute("src");
      return;
    }

    cur = plan[idx];
    const urlA = images[names.indexOf(cur.a)];
    const urlB = images[names.indexOf(cur.b)];

    const cached = decodedCache.get(idx);
    if (cached) { imgA.src = cached.aUrl; imgB.src = cached.bUrl; }
    else { setWithFallback(imgA, urlA); setWithFallback(imgB, urlB); }

    pairInfo.textContent = `第 ${idx + 1}/${plan.length} 组｜A: ${cur.a} ｜ B: ${cur.b}`;
    prog.textContent = `${idx}/${plan.length}`;
    bar.style.width = `${(idx / plan.length) * 100}%`;

    warmUpFrom(idx);
    decodedCache.delete(idx - 2);
  }

  function vote(choice) {
    if (idx >= plan.length) return;

    counts.set(cur.a, (counts.get(cur.a) || 0) + 1);
    counts.set(cur.b, (counts.get(cur.b) || 0) + 1);

    const payload = {
      timestamp: new Date().toISOString(),
      respondent_id: respondent || "anonymous",
      round_idx: idx + 1,
      image_a: cur.a,
      image_b: cur.b,
      choice,
      pair_id: pairKey(cur.a, cur.b),
      session_id: sessionId
    };

    postResult(payload);
    idx++; render();
  }

  function shuffle(arr){ for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
})();
</script>
